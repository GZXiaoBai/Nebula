// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'download.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`

/// 初始化下载管理器
///
/// 必须在使用其他下载功能之前调用
Future<void> initDownloadManager({required String downloadDir}) => RustLib
    .instance
    .api
    .crateApiDownloadInitDownloadManager(downloadDir: downloadDir);

/// 添加下载任务
///
/// 自动识别 URL 类型（HTTP/磁力链接/种子文件）
Future<String> addDownload({
  required String source,
  required String savePath,
}) => RustLib.instance.api.crateApiDownloadAddDownload(
  source: source,
  savePath: savePath,
);

/// 添加视频下载任务（指定画质）
Future<String> addVideoDownload({
  required String url,
  required String savePath,
  String? formatId,
}) => RustLib.instance.api.crateApiDownloadAddVideoDownload(
  url: url,
  savePath: savePath,
  formatId: formatId,
);

/// 暂停下载任务
Future<void> pauseDownload({required String taskId}) =>
    RustLib.instance.api.crateApiDownloadPauseDownload(taskId: taskId);

/// 恢复下载任务
Future<void> resumeDownload({required String taskId}) =>
    RustLib.instance.api.crateApiDownloadResumeDownload(taskId: taskId);

/// 取消下载任务
Future<void> cancelDownload({
  required String taskId,
  required bool deleteFiles,
}) => RustLib.instance.api.crateApiDownloadCancelDownload(
  taskId: taskId,
  deleteFiles: deleteFiles,
);

/// 订阅下载事件流
///
/// 返回一个 Stream，用于接收下载进度和状态变化
Future<Stream<NebulaEvent>> subscribeEvents() =>
    RustLib.instance.api.crateApiDownloadSubscribeEvents();

/// 检查 URL 是否为视频网站
Future<bool> isVideoUrl({required String url}) =>
    RustLib.instance.api.crateApiDownloadIsVideoUrl(url: url);

/// 获取视频信息
///
/// 需要系统已安装 yt-dlp
Future<VideoInfo> getVideoInfo({required String url}) =>
    RustLib.instance.api.crateApiDownloadGetVideoInfo(url: url);

/// 生成 Bilibili 登录二维码
Future<BilibiliQrCode> generateBilibiliQrcode({required String dataDir}) =>
    RustLib.instance.api.crateApiDownloadGenerateBilibiliQrcode(
      dataDir: dataDir,
    );

/// 轮询 Bilibili 扫码登录状态
Future<BilibiliLoginStatus> pollBilibiliLogin({
  required String dataDir,
  required String qrcodeKey,
}) => RustLib.instance.api.crateApiDownloadPollBilibiliLogin(
  dataDir: dataDir,
  qrcodeKey: qrcodeKey,
);

/// 检查 Bilibili 是否已登录
Future<bool> isBilibiliLoggedIn({required String dataDir}) =>
    RustLib.instance.api.crateApiDownloadIsBilibiliLoggedIn(dataDir: dataDir);

/// 注销 Bilibili 账号
Future<void> logoutBilibili({required String dataDir}) =>
    RustLib.instance.api.crateApiDownloadLogoutBilibili(dataDir: dataDir);

@freezed
sealed class BilibiliLoginStatus with _$BilibiliLoginStatus {
  const BilibiliLoginStatus._();

  /// 等待扫描
  const factory BilibiliLoginStatus.waitingScan() =
      BilibiliLoginStatus_WaitingScan;

  /// 已扫描待确认
  const factory BilibiliLoginStatus.waitingConfirm() =
      BilibiliLoginStatus_WaitingConfirm;

  /// 登录成功
  const factory BilibiliLoginStatus.success() = BilibiliLoginStatus_Success;

  /// 二维码已过期
  const factory BilibiliLoginStatus.expired() = BilibiliLoginStatus_Expired;

  /// 登录失败
  const factory BilibiliLoginStatus.failed({required String error}) =
      BilibiliLoginStatus_Failed;
}

/// Bilibili 二维码数据
@freezed
sealed class BilibiliQrCode with _$BilibiliQrCode {
  const factory BilibiliQrCode({
    required String url,
    required String qrcodeKey,
  }) = _BilibiliQrCode;
}

@freezed
sealed class NebulaEvent with _$NebulaEvent {
  const NebulaEvent._();

  const factory NebulaEvent.taskAdded({
    required String taskId,
    required String name,
  }) = NebulaEvent_TaskAdded;
  const factory NebulaEvent.taskStarted({required String taskId}) =
      NebulaEvent_TaskStarted;
  const factory NebulaEvent.progressUpdated({
    required String taskId,
    required ProgressEvent progress,
  }) = NebulaEvent_ProgressUpdated;
  const factory NebulaEvent.taskCompleted({required String taskId}) =
      NebulaEvent_TaskCompleted;
  const factory NebulaEvent.taskFailed({
    required String taskId,
    required String error,
  }) = NebulaEvent_TaskFailed;
  const factory NebulaEvent.taskPaused({required String taskId}) =
      NebulaEvent_TaskPaused;
  const factory NebulaEvent.taskResumed({required String taskId}) =
      NebulaEvent_TaskResumed;
  const factory NebulaEvent.taskRemoved({required String taskId}) =
      NebulaEvent_TaskRemoved;
  const factory NebulaEvent.metadataReceived({
    required String taskId,
    required String name,
    required BigInt totalSize,
    required BigInt fileCount,
  }) = NebulaEvent_MetadataReceived;
}

/// 进度事件（传递给 Dart）
@freezed
sealed class ProgressEvent with _$ProgressEvent {
  const factory ProgressEvent({
    required String taskId,
    required BigInt totalSize,
    required BigInt downloadedSize,
    required BigInt downloadSpeed,
    required double percentage,
    BigInt? etaSecs,
  }) = _ProgressEvent;
}

/// 视频格式选项
@freezed
sealed class VideoFormat with _$VideoFormat {
  const factory VideoFormat({
    required String formatId,
    required String ext,
    String? resolution,
    BigInt? filesize,
    String? formatNote,
    double? fps,
    String? vcodec,
    String? acodec,
  }) = _VideoFormat;
}

/// 视频信息（传递给 Dart）
@freezed
sealed class VideoInfo with _$VideoInfo {
  const factory VideoInfo({
    required String id,
    required String title,
    String? thumbnail,
    BigInt? duration,
    String? uploader,
    required List<VideoFormat> formats,
  }) = _VideoInfo;
}
